---
title: "`bnmonitor`: Checking the Robustness and Sensitivity of Bayesian Networks"
author: "Rachel Wilkerson, Manuele Leonelli, Ramsiya Ramanathan"
institute: "Baylor University, IE University, Madrid, Università di Bologna, Bologna, Italy"
date: "July 9, 2021"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    xaringan::moon_reader:
      css: ["useR", "useR-fonts"]

---
 
# Package Overview
- `bnmonitor` provides a suite of diagnostic monitors that can be used in increasing fineness to check the accuracy of forecasts flowing from a model 

- The sensitivity functions check the effect of changes to the probability distributions

- Robustness monitors work on BNs learned from data

- Sensitivity monitors work on BNs learned either from data or elicitation. Data can be either discrete or continous.

---

#Example: Diabetes 

We illustrate our package with what the UCI Repository refers to as the Pima Indian dataset. 
It consists of 392 observation with the following variables, discretized according to XX
 
- PREG: number of times pregnant (low/high)

- GLUC: plasma glucose concentration (low/high)

- PRES: diastolic blood pressure (low/high)

- TRIC: triceps skin fold thickness (low/high)

- INS: 2-hour serum insulin (low/high)

- MASS: body mass index (low/high)

- PED: diabetes pedigree function (low/high)

- AGE: age (low/high)

- DIAB: test for diabetes (neg/pos)

---

background-image: url("libs/img/women-Pima-shinny-game-field-hockey.jpeg")
background-position: contain
class: center, bottom, inverse

We chose this dataset as it best showcases our monitors. However, we acknowledge that we are using the data without compensating the original Akimel O’odham participants. 
The isolation imposed by the political boundaries of this isolation created a useful dataset at the expense of the liberty of the Akimel O’odham. 
XX footnote digital natives

???
Image credit: [Britannica](https://www.britannica.com/topic/Pima-people)

---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)

library("bnmonitor")
library("bnlearn")
library("qgraph")
library("ggplot2")

load("diabetes.RData")
```

```{r eval=require('DT'), tidy=FALSE,echo=FALSE}
DT::datatable(
  head(diabetes, 10),
  fillContainer = FALSE, options = list(pageLength = 8)
)
```
---
# Bayesian Network 

```{r dag}

dag  <- hc(diabetes)
qgraph(dag)
```

---
class: inverse, center, middle

# Robustness

---
``` {r glb}
global_monitor(dag = dag , df = diabetes,alpha=2)

```

- $\alpha$ is commonly set as the maximum number of levels for a node in the dataset

???
global monitors are used to compare moodels
---
# Prequential Monitors

\citet{Dawid1992} and were developed in \citet{Cowell2006,Cowell2007}
- $p_i$ gives the predictive density of the BN learned using the dataset $x_{[i-1]}$ including only the first $i-1$-th observations

- the level of surprise of observing the value $y_j\in\mathbb{Y}_j$ for the $j$-th variable after having processed $i$ observations is:  
$$S_{ij} = -\log(p_i(y_j)))$$

- We use the logarithmic score function here, but other score functions can certainly be used. 

---
# Standardization

- Relative standardization compares the log likelihood contributions to two different models. 

- Absolute standardization computes a Z-statistic using the following expectation and variance

- $$E_{ij} = \sum_{y_j\in\mathbb{Y}_j}p_i(y_j)\log(p_i(y_j))$$

- $$V_{ij}=\sum_{y_j\in\mathbb{Y}_j}p_i(y_j)\log(p_i(y_j))^2-E_{ij}^2$$

- $$Z_{ij}=\frac{\sum_{k=1}^iS_{kj}-\sum_{k=1}^iE_{kj}}{\sqrt{\sum_{k=1}^i}V_{kj}}$$

- values of and  $| Z_{ij}|> 1.96$ in absolute value may be an indication of poor model fit

---
# Marginal node monitors 

- Marginal and conditional node monitors check the appropriateness of the probability distributions of each node

``` {r node good fit,warning=FALSE, include=TRUE}
marg.ped <- plot(seq_marg_monitor(dag, diabetes, "PED"))
marg.ped + geom_hline(yintercept = 1.96, linetype='dashed', col = 'red') +  geom_hline(yintercept = -1.96, linetype='dashed', col = 'red')
```

- The marginal node monitor for PED (diabetes pedigree function) indicates a good fit.

???
Node monitors are used to assess the accuracty of forecasts.
We are most often concerned about this with the 'final outcome' nodes. 
Here the pedigree of diabetes suggests that the forecasts flowing from the model are accurate.
---
# Marginal node monitors 

``` {r node bad fit, warning=FALSE, include=TRUE, echo=FALSE}
marg.diab <- plot(seq_marg_monitor(dag, diabetes, "DIAB"))
marg.diab + geom_hline(yintercept = 1.96, linetype='dashed', col = 'red') +  geom_hline(yintercept = -1.96, linetype='dashed', col = 'red')
```

- The marginal node monitor for DIAB (diabetes) suggests that the the marginal distribution may be inappropriate for later forecasts.

???
By contrast, the marginal sequential node monitor suggests that the probability distribution for the node  diabetes is not necessarily accurate for later observation in the data. 

---
# Conditional node monitors 

``` {r cond monitor, warning=FALSE, include=TRUE, echo=FALSE}
cond.preg <- plot(seq_cond_monitor(dag, diabetes, "PREG")) 
cond.preg + geom_hline(yintercept = 1.96, linetype='dashed', col = 'red') +  geom_hline(yintercept = -1.96, linetype='dashed', col = 'red')
```

- The conditional node monitor for PREG (pregnancy) indicates a poor fit to early forecasts in the data. 

---
# Parent child monitor


```{r pach monitor,warning=FALSE, include=TRUE}
plot(seq_pa_ch_monitor(dag , diabetes , "PREG",pa.names = "AGE", pa.val = "low",alpha=2))+ geom_hline(yintercept = 1.96, linetype='dashed', col = 'red') +  geom_hline(yintercept = -1.96, linetype='dashed', col = 'red')
```

??? 

We can further probe this with the parent child monitor. 
We check all possible values of the parent nodes and find that young women in particular are difficult to predict pregnancies for.

---

class: inverse, center, middle

# Sensitivity

---

``` {r bnfit, include = FALSE}
bn <- bn.fit(dag , diabetes)
```
---
``` {r sens fig.show="hold", out.width="50%"}
sens_dc <- sensitivity(bn, interest_node = "DIAB", interest_node_value = "pos", node = "GLUC", value_node = "high", value_parents = NULL, new_value = "all")
sens_dic  <-   sensitivity(bn , interest_node = "DIAB",interest_node_value =   "pos",evidence_nodes = "INS", evidence_states = "low",node = "GLUC", value_node = "high",value_parents = NULL , new_value = "all")
par(mfrow=c(1,2))
plot(sens_dc)
plot(sens_dic)  
```
---

``` {r cd fig.show="hold", out.width="50%"}                    
cd_g <- CD(bn , node = "GLUC", value_node = "high",value_parents = NULL , new_value = "all")
cd_d <- CD(bn , node = "DIAB", value_node = "pos",value_parents = c("high","high"), new_value = "all")
par(mfrow=c(1,2))
plot(cd_g); plot(cd_d)
```
---

``` {r snsqury}          
snsqur.diab <- sensquery(bn, interest_node = "DIAB",interest_node_value = "pos", new_value = 0.4,evidence_nodes = "PRES", evidence_states = "high");
kable(snsqur.diab)
```

---

???

Image credit: [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Sharingan_triple.svg)



You are recommended to use the [RStudio IDE](https://www.rstudio.com/products/rstudio/), but you do not have to.

- Create a new R Markdown document from the menu `File -> New File -> R Markdown -> From Template -> Ninja Presentation`;<sup>1</sup>

--

- Click the `Knit` button to compile it;

--

- or use the [RStudio Addin](https://rstudio.github.io/rstudioaddins/)<sup>2</sup> "Infinite Moon Reader" to live preview the slides (every time you update and save the Rmd document, the slides will be automatically reloaded in RStudio Viewer.

.footnote[
[1] 中文用户请看[这份教程](https://slides.yihui.org/xaringan/zh-CN.html)

[2] See [#2](https://github.com/yihui/xaringan/issues/2) if you do not see the template or addin in RStudio.
]

---
background-image: url(`r xaringan:::karl`)
background-position: 50% 50%
class: center, bottom, inverse

# You only live once!

---

# Hello Ninja

As a presentation ninja, you certainly should not be satisfied by the "Hello World" example. You need to understand more about two things:

1. The [remark.js](https://remarkjs.com) library;

1. The **xaringan** package;

Basically **xaringan** injected the chakra of R Markdown (minus Pandoc) into **remark.js**. The slides are rendered by remark.js in the web browser, and the Markdown source needed by remark.js is generated from R Markdown (**knitr**).

---

# remark.js

You can see an introduction of remark.js from [its homepage](https://remarkjs.com). You should read the [remark.js Wiki](https://github.com/gnab/remark/wiki) at least once to know how to

- create a new slide (Markdown syntax<sup>*</sup> and slide properties);

- format a slide (e.g. text alignment);

- configure the slideshow;

- and use the presentation (keyboard shortcuts).

It is important to be familiar with remark.js before you can understand the options in **xaringan**.

.footnote[[*] It is different with Pandoc's Markdown! It is limited but should be enough for presentation purposes. Come on... You do not need a slide for the Table of Contents! Well, the Markdown support in remark.js [may be improved](https://github.com/gnab/remark/issues/142) in the future.]

---
background-image: url(`r xaringan:::karl`)
background-size: cover
class: center, bottom, inverse

# I was so happy to have discovered remark.js!

---
class: inverse, middle, center

# Using xaringan

---

# xaringan

Provides an R Markdown output format `xaringan::moon_reader` as a wrapper for remark.js, and you can use it in the YAML metadata, e.g.

```yaml
---
title: "A Cool Presentation"
output:
  xaringan::moon_reader:
    yolo: true
    nature:
      autoplay: 30000
---
```

See the help page `?xaringan::moon_reader` for all possible options that you can use.

---

# remark.js vs xaringan

Some differences between using remark.js (left) and using **xaringan** (right):

.pull-left[
1. Start with a boilerplate HTML file;

1. Plain Markdown;

1. Write JavaScript to autoplay slides;

1. Manually configure MathJax;

1. Highlight code with `*`;

1. Edit Markdown source and refresh browser to see updated slides;
]

.pull-right[
1. Start with an R Markdown document;

1. R Markdown (can embed R/other code chunks);

1. Provide an option `autoplay`;

1. MathJax just works;<sup>*</sup>

1. Highlight code with `{{}}`;

1. The RStudio addin "Infinite Moon Reader" automatically refreshes slides on changes;
]

.footnote[[*] Not really. See next page.]

---

# Math Expressions

You can write LaTeX math expressions inside a pair of dollar signs, e.g. &#36;\alpha+\beta$ renders $\alpha+\beta$. You can use the display style with double dollar signs:

```
$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$
```

$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$

Limitations:

1. The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;

1. There should not be spaces after the opening `$` or before the closing `$`.

1. Math does not work on the title slide (see [#61](https://github.com/yihui/xaringan/issues/61) for a workaround).

---

# R Code

```{r comment='#'}
# a boring regression
fit = lm(dist ~ 1 + speed, data = cars)
coef(summary(fit))
dojutsu = c('地爆天星', '天照', '加具土命', '神威', '須佐能乎', '無限月読')
grep('天', dojutsu, value = TRUE)
```

---

# R Plots

```{r cars, fig.height=4, dev='svg'}
par(mar = c(4, 4, 1, .1))
plot(cars, pch = 19, col = 'darkgray', las = 1)
abline(fit, lwd = 2)
```

---

# Tables

If you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,

```{r}
knitr::kable(head(iris), format = 'html')
```

---

# HTML Widgets

I have not thoroughly tested HTML widgets against **xaringan**. Some may work well, and some may not. It is a little tricky.

Similarly, the Shiny mode (`runtime: shiny`) does not work. I might get these issues fixed in the future, but these are not of high priority to me. I never turn my presentation into a Shiny app. When I need to demonstrate more complicated examples, I just launch them separately. It is convenient to share slides with other people when they are plain HTML/JS applications.

See the next page for two HTML widgets.

---

```{r out.width='100%', fig.height=6, eval=require('leaflet')}
library(leaflet)
leaflet() %>% addTiles() %>% setView(-93.65, 42.0285, zoom = 17)
```

